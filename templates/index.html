<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>LLM Debate System</title>
    <style>
        body { font-family: sans-serif; margin: 2em; line-height: 1.6; }
        .container { max-width: 800px; margin: auto; padding: 1em; border: 1px solid #ccc; border-radius: 5px; }
        label { display: block; margin-bottom: 0.5em; font-weight: bold; }
        textarea { width: 100%; padding: 0.5em; margin-bottom: 1em; box-sizing: border-box; }
        button { padding: 0.7em 1.5em; background-color: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .output-area { margin-top: 2em; }
        .status-log { max-height: 200px; overflow-y: auto; border: 1px solid #eee; background-color: #f9f9f9; padding: 0.5em 1em; margin-bottom: 1em; border-radius: 3px; font-size: 0.9em; }
        .status-log p { margin: 0.3em 0; padding: 0; }
        .result-box { margin-top: 1em; padding: 1em; border: 1px solid #ddd; background-color: #f0f0f0; border-radius: 3px; white-space: pre-wrap; }
        .error { color: red; margin-bottom: 1em; font-weight: bold; }
        .loader { display: none; /* Hidden by default */ border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; margin-left: 10px; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <div class="container">
        <h1>LLM Debate System</h1>

        <!-- Form will now use GET, handled by JS -->
        <form id="debate-form">
            <label for="question">Enter your debate question:</label>
            <textarea id="question" name="question" rows="3" required>{{ request.args.get('question', '') }}</textarea>
            <button type="submit" id="submit-button">Run Debate <span class="loader" id="loader"></span></button>
        </form>

        <div class="output-area" id="output-area">
            <div class="status-log" id="status-log"></div>
            
            <div id="error-message" class="error"></div>
            
            <h2>Baseline Result:</h2>
            <div id="baseline-output" class="result-box">Waiting for baseline...</div>

            <h2>Critique Results:</h2>
            <div id="critique-output" class="result-box">Waiting for critique...</div>

            <!-- ADDED: Section for Debate Round Results -->
            <h2>Debate Rounds:</h2>
            <div id="debate-rounds-output" class="result-box">Waiting for debate rounds...</div>
            <!-- END ADDED -->

            <h2>Merge Result:</h2>
            <div id="merge-output" class="result-box">Waiting for merge...</div>

            <h2>Summary Result:</h2>
            <div id="summary-output" class="result-box">Waiting for summary...</div>

            <h2>Refined Answer:</h2>
            <div id="refine-output" class="result-box">Waiting for refinement...</div>

            <h2>Judge Result:</h2>
            <div id="judge-output" class="result-box">Waiting for judge...</div>
            
            <h2>Final Answer:</h2>
            <div id="final-answer-output" class="result-box">Waiting for final answer...</div>
        </div>

    </div>

    <!-- Use Server-Sent Events for streaming progress -->
    <script>
        const form = document.getElementById('debate-form');
        const questionInput = document.getElementById('question');
        const submitButton = document.getElementById('submit-button');
        const loader = document.getElementById('loader');
        const statusLog = document.getElementById('status-log');
        const errorMessage = document.getElementById('error-message');
        const baselineOutput = document.getElementById('baseline-output');
        const critiqueOutput = document.getElementById('critique-output');
        const mergeOutput = document.getElementById('merge-output');
        const summaryOutput = document.getElementById('summary-output');
        const refineOutput = document.getElementById('refine-output');
        const judgeOutput = document.getElementById('judge-output');
        const finalAnswerOutput = document.getElementById('final-answer-output');
        const debateRoundsOutput = document.getElementById('debate-rounds-output');

        form.addEventListener('submit', function(event) {
            event.preventDefault();
            const question = questionInput.value.trim();
            if (!question) {
                errorMessage.textContent = 'Please enter a question.';
                return;
            }
            // Reset UI
            errorMessage.textContent = '';
            statusLog.innerHTML = '';
            baselineOutput.textContent = 'Waiting for baseline...';
            critiqueOutput.textContent = 'Waiting for critique...';
            mergeOutput.textContent = 'Waiting for merge...';
            summaryOutput.textContent = 'Waiting for summary...';
            refineOutput.textContent = 'Waiting for refinement...';
            judgeOutput.textContent = 'Waiting for judge...';
            finalAnswerOutput.textContent = 'Waiting for final answer...';
            debateRoundsOutput.textContent = 'Waiting for debate rounds...';
            loader.style.display = 'inline-block';
            submitButton.disabled = true;

            const evtSource = new EventSource(`/debate?question=${encodeURIComponent(question)}`);
            // Debug: log every message if needed
            evtSource.onmessage = e => console.debug('SSE onmessage:', e);

            evtSource.addEventListener('status', e => {
                console.debug('SSE status:', e.data);
                const msg = JSON.parse(e.data);
                const p = document.createElement('p'); p.textContent = msg;
                statusLog.appendChild(p);
                statusLog.scrollTop = statusLog.scrollHeight;
            });
            // Handle human feedback requests
            evtSource.addEventListener('feedback_request', e => {
                const promptText = JSON.parse(e.data);
                // Prompt the user for input
                const userFeedback = window.prompt(promptText, '');
                // Send the feedback back to the server
                fetch(`/debate/feedback?feedback=${encodeURIComponent(userFeedback || '')}`);
            });
            evtSource.addEventListener('baseline_result', e => {
                console.debug('SSE baseline_result:', e.data);
                baselineOutput.textContent = JSON.parse(e.data);
            });
            evtSource.addEventListener('critique_complete', e => {
                console.debug('SSE critique_complete:', e.data);
                const data = JSON.parse(e.data);
                let html = '';
                for (let agent in data) {
                    const rawResponse = data[agent].raw_response || (data[agent].error ? `Error: ${data[agent].error}` : 'No response received');
                    html += `<div><b>${agent}:</b><pre>${escapeHtml(rawResponse)}</pre></div>`;
                }
                critiqueOutput.innerHTML = html;
            });
            evtSource.addEventListener('debate_round_result', e => {
                console.debug('SSE debate_round_result:', e.data);
                const roundData = JSON.parse(e.data);
                const roundNum = roundData.round;
                const results = roundData.results;

                // Create HTML for this round
                let roundHtml = `<h3>Round ${roundNum}</h3>`;
                for (let agent in results) {
                    const agentData = results[agent];
                    // Display raw response for now, adjust as needed
                    const rawResponse = agentData.raw_response || (agentData.error ? `Error: ${agentData.error}` : 'No response');
                    roundHtml += `<div><b>${agent}:</b><pre>${escapeHtml(rawResponse)}</pre></div>`;
                }

                // Clear the 'Waiting...' message on the first round result or append otherwise
                if (debateRoundsOutput.textContent === 'Waiting for debate rounds...') {
                    debateRoundsOutput.innerHTML = roundHtml;
                } else {
                    debateRoundsOutput.innerHTML += roundHtml;
                }
                // Optional: Auto-scroll
                // debateRoundsOutput.scrollTop = debateRoundsOutput.scrollHeight;
            });
            evtSource.addEventListener('merge_result', e => {
                console.debug('SSE merge_result:', e.data);
                const factors = JSON.parse(e.data);
                let html = '<ul>';
                factors.forEach(f => {
                    html += `<li><b>${f.name}</b> (Conf: ${f.confidence.toFixed(2)})</li>`;
                });
                html += '</ul>';
                mergeOutput.innerHTML = html;
            });
            evtSource.addEventListener('summary_result', e => {
                console.debug('SSE summary_result:', e.data);
                summaryOutput.textContent = JSON.parse(e.data);
            });
            evtSource.addEventListener('refine_result', e => {
                console.debug('SSE refine_result:', e.data);
                refineOutput.textContent = JSON.parse(e.data);
            });
            evtSource.addEventListener('judge_result', e => {
                console.debug('SSE judge_result:', e.data);
                const d = JSON.parse(e.data);
                let html = `<p><b>Decision:</b> ${d.decision}</p>`;
                if (d.ratings) html += `<p>Ratings: Base=${d.ratings.baseline}, Merged=${d.ratings.merged}</p>`;
                judgeOutput.innerHTML = html;
            });
            evtSource.addEventListener('final_answer', e => {
                console.debug('SSE final_answer:', e.data);
                finalAnswerOutput.textContent = JSON.parse(e.data);
            });
            evtSource.addEventListener('error', e => {
                console.debug('SSE error event:', e.data);
                const err = JSON.parse(e.data || '{}');
                errorMessage.textContent = err.error || 'Server error';
                loader.style.display = 'none';
                submitButton.disabled = false;
                evtSource.close();
            });
            evtSource.addEventListener('complete', () => {
                console.debug('SSE complete event');
                loader.style.display = 'none';
                submitButton.disabled = false;
                evtSource.close();
            });
        });

        // Add helper function to escape HTML characters for safe display in <pre>
        function escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }
    </script>
</body>
</html> 